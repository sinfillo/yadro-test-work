# yadro-test-work
Тестовое задание на позицию "Инженер по разработке ПО для систем хранения данных"

## Инструкция по сборке
Склонировать к себе проект:
```sh
git clone git@github.com:sinfillo/yadro-test-work.git
```
Появится папка `yadro-test-work`. Из папки проекта выполнить следующие команды:
```sh
mkdir build
cmake ..
make
```

В папке `build` появится исполняемый файл `tape_sorter`.

## Формат запуска

Программа запускается следующим образом:
```sh
tape_sorter input_file output_file N
```
Где `input_file` - путь до файла с входными данными, `output_file` - путь до файла, куда требуется вывести отсортированную последовательность, `N` - количество чисел во входной последовательности. Файл с входными данными должен содержать `N` целых чисел (в десятичной системе счисления), разделенных пробельными символами. В выходном файле они выводятся в отсортированном порядке, разделенные пробелами.

## Конфигурационный файл
В директории, где запускается алгоритм сортировки, должен лежать файл `config.txt`. В нём должны определяться параметры ленты:
- `rw_latency` это задержка на чтение/запись на ленте
- `shift_latency` это задержка на смещение ленты на одну позицию
- `seek_latency` это задержка на проматывание ленты
- `ram_size` это размер оперативной памяти (памяти с произвольным доступом), на которую можно считывать данные с ленты, в байтах
Задержки указываются в произвольных, но одинаковых единицах времени (для алгоритма важно только их отношение между собой). Размер оперативной памяти указывается в байтах. 

Ко всем величинам можно приписать один из суффиксов `K`, `M` или `G`. Эти суффиксы умножают величину параметра на $10^3$, $10^6$, $10^9$ соответственно. Значения итоговых параметров должны быть корректные и влезать в 64-битный тип данных.

В конфигурационном файле параметры указываются на отдельных строках. Название параметра и численное значение отделяются пробелом. Строки могут идти в любом порядке.

## Идея решения

Интерфейс `Tape` реализован как чисто абстрактный класс с описанными в условии тестового задания методами:
- Метод `Read()` читает данные с ленты. Метод `Write(int32_t)` записывает данные на ленту
- Методы `MoveForward()` и `MoveBack()` отвечают за смещение магнитной головки вперёд и назад соответственно
- Метод `Seek(size_t pos)` отвечает за "медленный произвольный доступ", перемотку ленты к произвольной позиции `pos` (абсолютная позиция, то есть за 0 принимается начало ленты).

Класс `FileTape` реализует интерфейс ленты путем записи данных в файл, путь к которому указывается в конструкторе класса. Работа с файлами в данный момент реализации задания осуществляется через `std::fstream`. 

Для сортировки предлагается воспользоваться идеей модели внешней памяти. Мы считаем ленту внешней памятью и начинаем считывать или писать не по одному числу за раз, а целыми блоками. Размер блока подбирается исходя из соображения, что время проматывания ленты в рамках работы с блоком должно быть кратно меньше, чем время на непосредственную работу с данными.

Функция `Sort` принимает ссылку на входную ленту, количество чисел на ленте, которые необходимо отсортировать, ссылку на выходную ленту, ссылку на предоставляемую вызывающей стороной буфферную ленту, а также данные о максимальном количестве считываемых целых чисел, которые можно считать с лент, и размер блока. Далее вызывается сортировка слиянием во внешней памяти. В ней массив данных разбивается на множество частей, части рекурсивно сортируются, а потом происходит слияние всех отсортированных частей. Слияние происходит путём считывания отсортированных блоков в RAM. Собственно, количество частей выбирается так, чтобы суммарно во время слияния рамер хранимых блоков приближался к размеру используемой памяти. Как известно, сортировка во внешней памяти работает за $O(\frac{N}{B} \log_{\frac{M}{B}} \frac{N}{B})$ операций чтения/записи блока из внешней памяти.

Отметим, что интерфейс ленты расширен методами `ReadAndMoveForward` и `WriteAndMoveForward`, которые объединяют операции чтения/записи и смешения ленты. Их реализация в общем случае простая, но в силу использования `std::fstream` для работы с файлами (для реализации интерфейса ленты) данные операции работают существенно быстрее (так как при работе с файловыми потоками необходимо явно смещаться по файлу, что занимает много времени и). Можно пойти другим путём и переписать работу с файлами с файлового потока ввода на прямые чтение и запись в файл с использованием буфферизации вручную.
